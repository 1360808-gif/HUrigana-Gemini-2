<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãµã‚ŠãŒãªãƒã‚¸ãƒƒã‚¯ï¼</title>
    <script src="https://unpkg.com/wanakana"></script>
    <style>
        /* è¦‹ãŸç›®ã¯å‰å›ã¨åŒã˜ãªã®ã§å®‰å¿ƒã—ã¦ãã ã•ã„ */
        body {
            font-family: "UD Digi Kyokasho N-R", "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“ N-R", "Hiragino Sans", sans-serif;
            background-color: #fcfcfc; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; color: #333;
        }
        header { flex: 1; display: flex; padding: 15px 20px; gap: 20px; background-color: #eef9ff; border-bottom: 2px solid #a6dcef; box-sizing: border-box; }
        .info-pane { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        h1 { color: #1a73e8; margin: 0 0 8px 0; font-size: 1.5rem; }
        .notice { background: white; padding: 10px; border-radius: 10px; border: 2px solid #ffcc00; font-size: 0.85rem; line-height: 1.6; }
        .input-pane { flex: 1; display: flex; }
        textarea { width: 100%; height: 100%; border: 2px solid #a6dcef; border-radius: 12px; padding: 12px; font-family: inherit; font-size: 16px; resize: none; box-sizing: border-box; outline: none; }
        main { flex: 2; padding: 20px 40px; overflow-y: auto; background: white; box-sizing: border-box; position: relative; }
        #output { font-size: 24px; line-height: 2.3; word-break: break-all; }
        rt { color: #d9534f; font-size: 0.5em; font-weight: bold; cursor: pointer; padding: 0 2px; }
        #status-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        #status-text { font-size: 2rem; font-weight: bold; color: #1a73e8; margin-bottom: 20px; }
        progress { width: 60%; height: 25px; }
        .tools { position: fixed; bottom: 15px; right: 20px; display: flex; gap: 10px; }
        .btn { background: #ff9f43; color: white; border: none; padding: 10px 20px; border-radius: 50px; font-weight: bold; cursor: pointer; box-shadow: 0 3px 0 #e67e22; }
        .btn.copy { background: #1a73e8; box-shadow: 0 3px 0 #0d47a1; }
    </style>
</head>
<body>
    <header>
        <div class="info-pane">
            <h1>âœ¨ ãµã‚ŠãŒãªãƒã‚¸ãƒƒã‚¯</h1>
            <div class="notice">
                âš ï¸ <strong>ã¡ã‚…ã†ã„ï¼š</strong><br>
                1. ã€ŒçŸ¥ã£ã¦ã€ã¯ã€Œã—ã£ã¦ã€ã¨èª­ã¿ã¾ã™ã€‚<br>
                2. ãŠã‹ã—ã„ãªï¼Ÿã¨æ€ã£ãŸã‚‰ã‚¯ãƒªãƒƒã‚¯ã§ç›´ã›ã¾ã™ã€‚
            </div>
        </div>
        <div class="input-pane">
            <textarea id="input" placeholder="æ–‡ç« ã‚’ã“ã“ã«å…¥åŠ›ã—ã¦ã­"></textarea>
        </div>
    </header>

    <main>
        <div id="status-overlay">
            <div id="status-text">ğŸª„ ã¾ã»ã†ã‚’ ã‹ã‘ã¦ã„ã¾ã™...</div>
            <progress id="progress-bar" value="0" max="100"></progress>
        </div>
        <div id="output"></div>
    </main>

    <div class="tools">
        <button class="btn copy" onclick="copyOutput()">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
        <button class="btn" onclick="clearAll()">ğŸ”„ ãœã‚“ã¶ã‘ã™</button>
    </div>

    <script>
        const input = document.getElementById('input');
        const output = document.getElementById('output');
        const overlay = document.getElementById('status-overlay');
        const progressBar = document.getElementById('progress-bar');
        let timer;

        // ã€æœ€å¼·ã®æŒ‡åæ‰‹é…ãƒªã‚¹ãƒˆã€‘
        // ã“ã“ã«æ›¸ã„ãŸå˜èªã¯ã€å•ç­”ç„¡ç”¨ã§ã“ã®èª­ã¿ã«å¤‰æ›ã—ã¾ã™ã€‚
        const priorityDictionary = {
            'çŸ¥ã£ã¦': 'ã—ã£ã¦',   // â† ä»Šå›ã®æœ€é‡è¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
            'çŸ¥ã£ã¦ã„ã‚‹': 'ã—ã£ã¦ã„ã‚‹',
            
            // ã¤ã„ã§ã«å‰å›ã®é˜²å¾¡ã‚‚ç¶­æŒ
            'è£åˆ‡': 'ã†ã‚‰ã',
            'è‡ªä¸»ç·´': 'ã˜ã—ã‚…ã‚Œã‚“',
            'çµ¶å‘½': 'ãœã¤ã‚ã„'
        };

        // 1æ–‡å­—ã®å‹•è©ã®èª­ã¿é–“é•ã„é˜²æ­¢
        const verbFixes = {
            'è¨€': 'ã„', 'çŸ¥': 'ã—', 'å‡º': 'ã§', 'åˆ†': 'ã‚', 'è¦‹': 'ã¿', 
            'ç”Ÿ': 'ã„', 'è¡Œ': 'ã„', 'æ€': 'ãŠã‚‚', 'æ›¸': 'ã‹', 'èª­': 'ã‚ˆ'
        };

        const segmenter = new Intl.Segmenter('ja-JP', { granularity: 'word' });

        input.addEventListener('input', () => {
            clearTimeout(timer);
            timer = setTimeout(processText, 800);
        });

        async function processText() {
            const text = input.value;
            if (!text.trim()) { output.innerHTML = ""; return; }

            const segments = Array.from(segmenter.segment(text));
            let htmlResult = "";
            
            overlay.style.display = "flex";
            progressBar.value = 0;
            progressBar.max = segments.length;

            for (let k = 0; k < segments.length; k++) {
                let word = segments[k].segment;
                let reading = "";

                if (/[\u4E00-\u9FFF\d]/.test(word)) { // æ¼¢å­—ã‹æ•°å­—ãŒå«ã¾ã‚Œã‚‹å ´åˆ
                    
                    // â˜…ã‚¹ãƒ†ãƒƒãƒ—1ï¼šæŒ‡åæ‰‹é…ãƒªã‚¹ãƒˆã®ãƒã‚§ãƒƒã‚¯
                    // ãã®å˜èªãŒãƒªã‚¹ãƒˆã«ã‚ã‚‹ã‹ã€ã¾ãŸã¯ãƒªã‚¹ãƒˆã®è¨€è‘‰ã§å§‹ã¾ã£ã¦ã„ã‚‹ã‹ç¢ºèª
                    let hit = Object.keys(priorityDictionary).find(key => word.startsWith(key));
                    
                    if (hit) {
                        // ãƒªã‚¹ãƒˆã«ã‚ã£ãŸã‚‰ã€ç™»éŒ²ã•ã‚ŒãŸèª­ã¿ã‚’ä½¿ã†ï¼
                        const baseReading = priorityDictionary[hit];
                        const suffix = word.substring(hit.length);
                        // æ®‹ã‚Šã®éƒ¨åˆ†ï¼ˆã‚ã‚Œã°ï¼‰ã®èª­ã¿ã‚’å–å¾—
                        const suffixReading = suffix ? await getReading(suffix) : "";
                        reading = baseReading + suffixReading;
                    } else {
                        // ãƒªã‚¹ãƒˆã«ãªã‘ã‚Œã°ã€é€šå¸¸é€šã‚ŠAPIã«èã
                        reading = await getReading(word);
                    }

                    // â˜…ã‚¹ãƒ†ãƒƒãƒ—2ï¼šåŠ›ã¥ãã®ä¿®æ­£ï¼ˆå¿µã®ãŸã‚ï¼‰
                    if (word.includes('è£åˆ‡')) reading = reading.replace(/ã†ã‚‰ã›ã¤|ã‚Šã›ã¤/g, 'ã†ã‚‰ã');
                    if (word.includes('è‡ªä¸»ç·´')) reading = 'ã˜ã—ã‚…ã‚Œã‚“';
                    // ã€ŒçŸ¥ã£ã¦ã€ãŒä¸‡ãŒä¸€å¤‰ãªèª­ã¿ã§æ¥ã¦ã‚‚ã€ã“ã“ã§ã‚‚ã‚­ãƒ£ãƒƒãƒã™ã‚‹
                    if (word === 'çŸ¥ã£ã¦' && reading !== 'ã—ã£ã¦') reading = 'ã—ã£ã¦'; 

                    // é€ã‚Šä»®åå‡¦ç†
                    let i = word.length - 1;
                    let j = reading.length - 1;
                    while (i >= 0 && j >= 0 && word[i] === reading[j] && !/[\u4E00-\u9FFF]/.test(word[i])) { i--; j--; }
                    
                    let kanjiPart = word.substring(0, i + 1);
                    const okuriganaPart = word.substring(i + 1);
                    let kanjiReading = reading.substring(0, j + 1);

                    // 1æ–‡å­—å‹•è©ã®è£œæ­£
                    if (kanjiPart.length === 1 && verbFixes[kanjiPart]) { kanjiReading = verbFixes[kanjiPart]; }

                    if (kanjiPart) { 
                        htmlResult += `<ruby>${kanjiPart}<rt contenteditable="true">${kanjiReading}</rt></ruby>${okuriganaPart}`; 
                    } else { 
                        htmlResult += word; 
                    }
                } else {
                    htmlResult += word;
                }
                progressBar.value = k + 1;
            }

            output.innerHTML = htmlResult;
            overlay.style.display = "none";
        }

        async function getReading(word) {
            try {
                // APIã¸ã®å•ã„åˆã‚ã›
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=ja&tl=ja&dt=rm&q=${encodeURIComponent(word)}`;
                const response = await fetch(url);
                const data = await response.json();
                let romaji = (data[0] && data[0][0] && data[0][0][3]) ? data[0][0][3] : "";
                
                // ãƒ­ãƒ¼ãƒå­—ã‚’ã²ã‚‰ãŒãªã«å¤‰æ›
                let fixed = romaji.toLowerCase().replace(/[~~\-ãƒ¼]/g, '');
                // é•·éŸ³è¨˜å·ã®å‡¦ç†
                const romajiMap = { 'Ä': 'aa', 'Ä«': 'ii', 'Å«': 'uu', 'Ä“': 'ei', 'Å': 'ou' };
                Object.keys(romajiMap).forEach(key => { fixed = fixed.split(key).join(romajiMap[key]); });
                
                return wanakana.toHiragana(fixed);
            } catch { return ""; }
        }

        function copyOutput() {
            const range = document.createRange();
            range.selectNodeContents(output);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            document.execCommand('copy');
            alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼");
        }

        function clearAll() { input.value = ""; output.innerHTML = ""; overlay.style.display = "none"; input.focus(); }
    </script>
</body>
</html>
