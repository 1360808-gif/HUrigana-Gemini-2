<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãµã‚ŠãŒãªãƒã‚¸ãƒƒã‚¯ï¼å®Œå…¨ç‰ˆ</title>
    <script src="https://unpkg.com/wanakana"></script>
    <style>
        body {
            font-family: "UD Digi Kyokasho N-R", "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“ N-R", "UD Digi Kyokasho NK-R", "UD ãƒ‡ã‚¸ã‚¿ãƒ« æ•™ç§‘æ›¸ä½“ NK-R", "Hiragino Sans", "Meiryo", sans-serif;
            background-color: #fcfcfc; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; color: #333;
        }
        header { flex: 1; display: flex; padding: 15px 20px; gap: 20px; background-color: #eef9ff; border-bottom: 2px solid #a6dcef; box-sizing: border-box; }
        .info-pane { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        h1 { color: #1a73e8; margin: 0 0 8px 0; font-size: 1.5rem; }
        .notice { background: white; padding: 10px; border-radius: 10px; border: 2px solid #ffcc00; font-size: 0.85rem; line-height: 1.6; }
        .input-pane { flex: 1; display: flex; }
        textarea { width: 100%; height: 100%; border: 2px solid #a6dcef; border-radius: 12px; padding: 12px; font-family: inherit; font-size: 16px; resize: none; box-sizing: border-box; outline: none; }
        
        main { flex: 2; padding: 20px 40px; overflow-y: auto; background: white; box-sizing: border-box; position: relative; }
        #output { font-size: 24px; line-height: 2.3; word-break: break-all; transition: opacity 0.3s; }
        rt { color: #d9534f; font-size: 0.5em; font-weight: bold; cursor: pointer; padding: 0 2px; }
        rt:hover { background: #ffebeb; border-radius: 3px; }

        #status-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        #status-text { font-size: 2rem; font-weight: bold; color: #1a73e8; margin-bottom: 20px; text-shadow: 1px 1px 0 white; }
        progress { width: 60%; height: 25px; appearance: none; border: none; }
        progress::-webkit-progress-bar { background-color: #eee; border-radius: 20px; }
        progress::-webkit-progress-value { background-color: #ff9f43; border-radius: 20px; transition: width 0.1s; }

        .tools { position: fixed; bottom: 15px; right: 20px; display: flex; gap: 10px; }
        .btn { background: #ff9f43; color: white; border: none; padding: 10px 20px; border-radius: 50px; font-family: inherit; font-weight: bold; cursor: pointer; box-shadow: 0 3px 0 #e67e22; font-size: 0.9rem; }
        .btn:active { transform: translateY(2px); box-shadow: none; }
        .btn.copy { background: #1a73e8; box-shadow: 0 3px 0 #0d47a1; }
    </style>
</head>
<body>

    <header>
        <div class="info-pane">
            <h1>âœ¨ ãµã‚ŠãŒãªãƒã‚¸ãƒƒã‚¯</h1>
            <div class="notice">
                âš ï¸ <strong>ã¡ã‚…ã†ã„ï¼š</strong>ã¤ã‘ã‚‰ã‚ŒãŸ ãµã‚ŠãŒãªã¯ã€ã¾ã¡ãŒã£ã¦ã„ã‚‹ ã¨ããŒ ã‚ã‚Šã¾ã™ã€‚<br>
                ğŸ’¡ <strong>ãƒ’ãƒ³ãƒˆï¼š</strong>ã¾ã¡ãŒã£ã¦ã„ã‚‹ ãµã‚ŠãŒãªã¯ã€ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ ã˜ã¶ã‚“ã§ ãªãŠã›ã‚‹ã‚ˆï¼
            </div>
        </div>
        <div class="input-pane">
            <textarea id="input" placeholder="ã“ã“ã«ã€ãµã‚ŠãŒãªã‚’ ã¤ã‘ãŸã„ æ–‡ç« ã‚’ ã¯ã‚Šã¤ã‘ã¦ã­ï¼"></textarea>
        </div>
    </header>

    <main>
        <div id="status-overlay">
            <div id="status-text">ğŸª„ ã¾ã»ã†ã‚’ ã‹ã‘ã¦ã„ã¾ã™...</div>
            <progress id="progress-bar" value="0" max="100"></progress>
        </div>
        <div id="output"></div>
    </main>

    <div class="tools">
        <button class="btn copy" onclick="copyOutput()">ğŸ“‹ ãµã‚ŠãŒãªã¤ãã§ ã‚³ãƒ”ãƒ¼</button>
        <button class="btn" onclick="clearAll()">ğŸ”„ ãœã‚“ã¶ã‘ã™</button>
    </div>

    <script>
        const input = document.getElementById('input');
        const output = document.getElementById('output');
        const overlay = document.getElementById('status-overlay');
        const progressBar = document.getElementById('progress-bar');
        let timer;

        // ã€A. å¼·åˆ¶è¾æ›¸ã€‘APIã‚’ä½¿ã‚ãšã«ã€ã“ã®å˜èªã¯ã“ã®èª­ã¿ã§å›ºå®šã™ã‚‹
        const hardDictionary = {
            'è‡ªä¸»ç·´': 'ã˜ã—ã‚…ã‚Œã‚“',
            'çµ¶å‘½': 'ãœã¤ã‚ã„',
            'æˆ¦åŠ›å¤–': 'ã›ã‚“ã‚Šã‚‡ããŒã„',
            'ä½•ã¨ã‹': 'ãªã‚“',
            'å¤§äºº': 'ãŠã¨ãª',
            'äººæ°—': 'ã«ã‚“ã'
        };

        // ã€B. èª­ã¿é–“é•ã„æ˜¯æ­£ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã€‘
        // [æ¼¢å­—] ã‚’ [é–“é•ã£ãŸèª­ã¿] ã¨åˆ¤å®šã—ãŸã‚‰ã€[æ­£ã—ã„èª­ã¿] ã«æ›¸ãæ›ãˆã‚‹
        // ç‰¹ã«ã€Œã€œãªã„ã€ã®ã¨ãã«ç™ºç”Ÿã—ã‚„ã™ã„éŸ³èª­ã¿ã‚¨ãƒ©ãƒ¼ã‚’ã“ã“ã§å¸åã—ã¾ã™
        const correctionMap = [
            { kanji: 'è£åˆ‡', wrong: 'ã†ã‚‰ã›ã¤', right: 'ã†ã‚‰ã' }, // è£åˆ‡ã‚‰ãªã„
            { kanji: 'è£åˆ‡', wrong: 'ã‚Šã›ã¤', right: 'ã†ã‚‰ã' },
            { kanji: 'æ±º', wrong: 'ã‘ã¤', right: 'ã' },       // æ±ºã¾ã‚‰ãªã„
            { kanji: 'åˆ†', wrong: 'ã¶ã‚“', right: 'ã‚' },       // åˆ†ã‹ã‚‰ãªã„
            { kanji: 'åˆ‡', wrong: 'ã›ã¤', right: 'ã' },       // åˆ‡ã‚‰ãªã„
            { kanji: 'æ–­', wrong: 'ã ã‚“', right: 'ã“ã¨ã‚' },   // æ–­ã‚‰ãªã„
            { kanji: 'é€š', wrong: 'ã¤ã†', right: 'ã¨ãŠ' },     // é€šã‚‰ãªã„
            { kanji: 'çš„', wrong: 'ã¾ã¨', right: 'ã¦ã' }      // ã€œçš„ãª
        ];

        const romajiMap = { 'Ä': 'aa', 'Ä«': 'ii', 'Å«': 'uu', 'Ä“': 'ei', 'Å': 'ou' };
        const segmenter = new Intl.Segmenter('ja-JP', { granularity: 'word' });

        input.addEventListener('input', () => {
            clearTimeout(timer);
            timer = setTimeout(processText, 800);
        });

        async function processText() {
            const text = input.value;
            if (!text.trim()) { output.innerHTML = ""; return; }

            const segments = Array.from(segmenter.segment(text));
            let htmlResult = "";
            
            overlay.style.display = "flex";
            output.style.opacity = "0.2";
            progressBar.value = 0;
            progressBar.max = segments.length;

            for (let k = 0; k < segments.length; k++) {
                let word = segments[k].segment;
                let prevWord = k > 0 ? segments[k-1].segment : "";
                
                if (/[\u4E00-\u9FFF\d]/.test(word)) {
                    
                    // 1. æ¼¢å­—éƒ¨åˆ†ã¨é€ã‚Šä»®åã‚’å¼·åˆ¶åˆ†é›¢
                    let match = word.match(/^([\u4E00-\u9FFF\dã€…]+)(.*)$/);
                    let kanjiPart = word;
                    let okuriganaPart = "";
                    if (match) {
                        kanjiPart = match[1];
                        okuriganaPart = match[2];
                    }

                    let kanjiReading = "";
                    let isForced = false;

                    // 2. è¾æ›¸ãƒã‚§ãƒƒã‚¯ï¼ˆå®Œå…¨ä¸€è‡´ï¼‰
                    for (let key in hardDictionary) {
                        if (kanjiPart === key || word.includes(key)) {
                            // è¾æ›¸ã«ã‚ã‚‹å˜èªãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰ãã‚Œã‚’ä½¿ã†
                            // ãŸã ã—è¾æ›¸ã‚­ãƒ¼ãŒã€Œè‡ªä¸»ç·´ã€ã§ wordãŒã€Œè‡ªä¸»ç·´ã€ãªã‚‰OK
                            if (kanjiPart === key) {
                                kanjiReading = hardDictionary[key];
                                isForced = true;
                                break;
                            }
                        }
                    }

                    if (!isForced) {
                        // 3. ç‰¹åˆ¥ãƒ«ãƒ¼ãƒ«ï¼šæ•°å­—ï¼‹å¹´
                        if ((word === "å¹´" && /[\dï¼-ï¼™]/.test(prevWord)) || /^\d+å¹´$/.test(word)) {
                            kanjiReading = "ã­ã‚“";
                        } else {
                            // 4. APIã¸å•ã„åˆã‚ã›
                            let fullReading = await getReading(word);
                            
                            // é€ã‚Šä»®åã‚’é™¤å»ã—ã¦ã€æ¼¢å­—éƒ¨åˆ†ã ã‘ã®èª­ã¿ã‚’æŠ½å‡º
                            if (fullReading.endsWith(okuriganaPart)) {
                                kanjiReading = fullReading.substring(0, fullReading.length - okuriganaPart.length);
                            } else {
                                // APIãŒå¤‰ãªæ´»ç”¨ã‚’ã—ã¦ã„ã‚‹å ´åˆã€ã¨ã‚Šã‚ãˆãšå¾Œã‚ã‹ã‚‰å‰Šã‚‹
                                kanjiReading = fullReading;
                                if (okuriganaPart.length > 0) {
                                     // æ–‡å­—æ•°åˆ†ã ã‘ã‚«ãƒƒãƒˆã‚’è©¦ã¿ã‚‹ï¼ˆç²¾åº¦ã¯è½ã¡ã‚‹ãŒå®‰å…¨ç­–ï¼‰
                                     kanjiReading = fullReading.substring(0, Math.max(0, fullReading.length - okuriganaPart.length));
                                }
                            }

                            // 5. ã€é‡è¦ã€‘èª­ã¿é–“é•ã„æ˜¯æ­£ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ç™ºå‹•
                            // ã“ã“ã§ã€Œã‘ã¤ã€â†’ã€Œãã€ã®ã‚ˆã†ãªå¤‰æ›ã‚’è¡Œã†
                            for (let correction of correctionMap) {
                                if (kanjiPart === correction.kanji && kanjiReading === correction.wrong) {
                                    kanjiReading = correction.right;
                                    break;
                                }
                                // éƒ¨åˆ†ä¸€è‡´ï¼ˆè£åˆ‡ãªã©ï¼‰
                                if (kanjiPart.includes(correction.kanji) && kanjiReading.includes(correction.wrong)) {
                                     kanjiReading = kanjiReading.replace(correction.wrong, correction.right);
                                }
                            }
                        }
                    }

                    // 1æ–‡å­—ã®å‹•è©ã®ä¿é™ºï¼ˆè¨€â†’ã„ã€ãªã©ï¼‰
                    const simpleVerbFixes = {'è¨€':'ã„','çŸ¥':'ã—','å‡º':'ã§','è¦‹':'ã¿','è¡Œ':'ã„','èª­':'ã‚ˆ','æ›¸':'ã‹','æ€':'ãŠã‚‚'};
                    if (!isForced && kanjiPart.length === 1 && simpleVerbFixes[kanjiPart] && kanjiReading !== simpleVerbFixes[kanjiPart]) {
                        // èª­ã¿ãŒæ˜ã‚‰ã‹ã«éŸ³èª­ã¿ï¼ˆé•·ã„ã€é•ã†ï¼‰å ´åˆã¯è£œæ­£ã™ã‚‹
                        // ã“ã“ã¯æ…é‡ã«è¡Œã†å¿…è¦ãŒã‚ã‚‹ãŒã€1æ–‡å­—ï¼‹é€ã‚Šä»®åã®ã¨ãã¯è¨“èª­ã¿ã®å¯èƒ½æ€§ãŒé«˜ã„
                        if (okuriganaPart.length > 0) {
                            kanjiReading = simpleVerbFixes[kanjiPart];
                        }
                    }
                    
                    if (kanjiPart) {
                        htmlResult += `<ruby>${kanjiPart}<rt contenteditable="true">${kanjiReading}</rt></ruby>${okuriganaPart}`;
                    } else {
                        htmlResult += word;
                    }

                } else {
                    htmlResult += word;
                }
                progressBar.value = k + 1;
            }

            output.innerHTML = htmlResult;
            output.style.opacity = "1";
            overlay.style.display = "none";
        }

        async function getReading(word) {
            try {
                const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=ja&tl=ja&dt=rm&q=${encodeURIComponent(word)}`;
                const response = await fetch(url);
                const data = await response.json();
                let romaji = (data[0] && data[0][0] && data[0][0][3]) ? data[0][0][3] : "";
                let fixed = romaji.toLowerCase().replace(/[~~\-ãƒ¼\s]/g, '');
                Object.keys(romajiMap).forEach(key => { fixed = fixed.split(key).join(romajiMap[key]); });
                return wanakana.toHiragana(fixed);
            } catch { return ""; }
        }

        function copyOutput() {
            const range = document.createRange();
            range.selectNodeContents(output);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            document.execCommand('copy');
            alert("ã‚³ãƒ”ãƒ¼ã—ãŸã‚ˆï¼");
        }

        function clearAll() { input.value = ""; output.innerHTML = ""; overlay.style.display = "none"; input.focus(); }
    </script>
</body>
</html>
